<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>cubes</title>
    <style>
        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <script type="module">
        import Stats from '../node_modules/stats.js/src/Stats.js';
        import { GPU, Context, loadImage } from '../src/index.js';
        import vsCode from './shaders/instanced_vertex.glsl.js';
        import fsCode from './shaders/instanced_fragment.glsl.js';
        import { mat4, vec3 } from '../node_modules/gl-matrix/esm/index.js';

        const sampleCount = 4;

        let width = window.innerWidth;
        let height =  window.innerHeight;

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        document.body.appendChild(canvas);

        let gpu, context;

        async function main() {
            gpu = new GPU();
            await gpu.init();

            context = new Context(canvas);
            await context.init(gpu.device);

            const renderPipeline = gpu.createRenderPipeline(vsCode, fsCode, {
                // indexFormat: 'uint32',
                vertexBuffers: [{
                    arrayStride: 4 * 5,
                    attributes: [
                        // position
                        {
                            shaderLocation: 0,
                            offset: 0,
                            format: 'float3'
                        },
                        // uv
                        {
                            shaderLocation: 1,
                            offset: 4 * 3,
                            format: 'float2'
                        }
                    ]
                }]
            }, {
                entries: [{
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    type: 'uniform-buffer'
                }, {
                    binding: 1,
                    visibility: GPUShaderStage.VERTEX,
                    type: 'uniform-buffer'
                }, {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    type: "sampler"
                }, {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    type: "sampled-texture"
                }]
            }, context.format, sampleCount);
            renderPipeline.rasterizationState = {
                frontFace: "cw"
            };
            renderPipeline.depthStencilState = {
                depthWriteEnabled: true,
                depthCompare: "less",
                format: "depth24plus-stencil8"
            };

            let colorTexture = gpu.device.createTexture({
                size: {
                    width: canvas.width,
                    height: canvas.height,
                    depth: 1,
                },
                sampleCount,
                format: context.format,
                usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
            });

            let depthTexture = gpu.device.createTexture({
                size: {
                    width: canvas.width,
                    height: canvas.height,
                    depth: 1,
                },
                sampleCount,
                format: "depth24plus-stencil8",
                usage: GPUTextureUsage.OUTPUT_ATTACHMENT
            });

            // texture

            const sampler = gpu.device.createSampler({
                magFilter: "linear",
                minFilter: "linear",
                mipmapFilter: "linear"
            });

            const imageInfo = await loadImage('./textures/crate.gif'); // TODO generate mipmaps
            const texture = gpu.createTexture(imageInfo.data, imageInfo.width, imageInfo.height);

            // camera

            const pMatrix = mat4.perspective(mat4.create(), Math.PI / 4, width / height, 0.1, 1000);

            // cubes

            const cubeVertexBuffer = gpu.createBuffer(new Float32Array([
                // float3 position, float2 uv,
                1, -1, 1,   1, 1,
                -1, -1, 1,  0, 1,
                -1, -1, -1, 0, 0,
                1, -1, -1,  1, 0,
                1, -1, 1,   1, 1,
                -1, -1, -1, 0, 0,

                1, 1, 1,    1, 1,
                1, -1, 1,   0, 1,
                1, -1, -1,  0, 0,
                1, 1, -1,   1, 0,
                1, 1, 1,    1, 1,
                1, -1, -1,  0, 0,

                -1, 1, 1,   1, 1,
                1, 1, 1,    0, 1,
                1, 1, -1,   0, 0,
                -1, 1, -1,  1, 0,
                -1, 1, 1,   1, 1,
                1, 1, -1,   0, 0,

                -1, -1, 1,  1, 1,
                -1, 1, 1,   0, 1,
                -1, 1, -1,  0, 0,
                -1, -1, -1, 1, 0,
                -1, -1, 1,  1, 1,
                -1, 1, -1,  0, 0,

                1, 1, 1,    1, 1,
                -1, 1, 1,   0, 1,
                -1, -1, 1,  0, 0,
                -1, -1, 1,  0, 0,
                1, -1, 1,   1, 0,
                1, 1, 1,    1, 1,

                1, -1, -1,  1, 1,
                -1, -1, -1, 0, 1,
                -1, 1, -1,  0, 0,
                1, 1, -1,   1, 0,
                1, -1, -1,  1, 1,
                -1, 1, -1,  0, 0,
            ]), GPUBufferUsage.VERTEX);

            const cubeIndexBuffer = gpu.createBuffer(new Uint32Array([
                0, 1, 2,
                3, 4, 5,
                6, 7, 8,
                9, 10, 11,
                12, 13, 14,
                15, 16, 17,
                18, 19, 20,
                21, 22, 23,
                24, 25, 26,
                27, 28, 29,
                30, 31, 32,
                33, 34, 35
            ]), GPUBufferUsage.INDEX);

            const num = 1000;
            const helpMat4 = mat4.create();
            const cubeMVMatrices = new Float32Array(16 * num);
            for (let i = 0; i < num; i++) {
                mat4.fromTranslation(helpMat4, new Float32Array([Math.random() * 50 - 25, Math.random() * 50 - 25, -100.0 + Math.random() * 50 - 25]));
                cubeMVMatrices.set(helpMat4, 16 * i);
            }

            const cubeUniformBuffer1 = gpu.createBuffer(pMatrix, GPUBufferUsage.UNIFORM);
            const cubeUniformBuffer2 = gpu.createBuffer(cubeMVMatrices, GPUBufferUsage.UNIFORM);
            const cubeUniformGroup = renderPipeline.createUniformGroup([
                cubeUniformBuffer1,
                cubeUniformBuffer2,
                sampler,
                texture
            ]);

            // resize handle

            window.addEventListener('resize', () => {
                width = window.innerWidth;
                height = window.innerHeight;

                canvas.width = width;
                canvas.height = height;

                if (colorTexture) {
                    colorTexture.destroy();

                    colorTexture = gpu.device.createTexture({
                        size: {
                            width: width,
                            height: height,
                            depth: 1,
                        },
                        sampleCount,
                        format: context.format,
                        usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
                    });
                }

                if (depthTexture) {
                    depthTexture.destroy();

                    depthTexture = gpu.device.createTexture({
                        size: {
                            width: width,
                            height: height,
                            depth: 1,
                        },
                        sampleCount,
                        format: "depth24plus-stencil8",
                        usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
                    });
                }

                mat4.perspective(pMatrix, Math.PI / 4, width / height, 0.1, 1000);

                cubeUniformBuffer1.dirty();
            });

            let stats = new Stats();
            stats.showPanel(1);
            document.body.appendChild(stats.dom);

            // render

            function render() {
                requestAnimationFrame(render);

                stats.begin();

                // rotate
                let i, j;
                for(i = 0; i < num; i++) {
                    for (j = 0; j < 16; j++) {
                        helpMat4[j] = cubeMVMatrices[i * 16 + j];
                    }
                    mat4.rotateY(helpMat4, helpMat4, 0.01);
                    cubeMVMatrices.set(helpMat4, i * 16);
                }
                cubeUniformBuffer2.dirty();

                gpu.createCommandEncoder();

                let uploadBuffers = [
                    cubeUniformBuffer1.$update(),
                    cubeUniformBuffer2.$update(),
                    texture.$update()
                ];

                gpu.beginRenderPass(
                    {
                        colorAttachments: [{
                            attachment: colorTexture.createView(),
                            resolveTarget: context.swapChain.getCurrentTexture().createView(),
                            loadValue: { r: 0, g: 0, b: 0, a: 1.0 }
                        }],
                        depthStencilAttachment: {
                            attachment: depthTexture.createView(),

                            depthLoadValue: 1.0,
                            depthStoreOp: "store",
                            stencilLoadValue: 0,
                            stencilStoreOp: "store",
                        }
                    },
                    width,
                    height
                );
                
                gpu.setPipeline(renderPipeline);

                gpu.bindAttributes({
                    vertexBuffers: [cubeVertexBuffer],
                    indexBuffer: cubeIndexBuffer
                });

                gpu.bindUniforms(cubeUniformGroup);

                gpu.draw(cubeIndexBuffer.array.length, num);

                gpu.present();

                uploadBuffers.forEach(uploadBuffer => {
                    if(uploadBuffer) uploadBuffer.destroy();
                });

                stats.end();
            }

            requestAnimationFrame(render);
        }

        main();
    </script>
</body>
</html>