<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>texture</title>
    <style>
        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <script type="module">
        import { GPU, Context, loadImage } from '../src/index.js';
        import vsCode from './shaders/map_vertex.glsl.js';
        import fsCode from './shaders/map_fragment.glsl.js';
        import { mat4, vec3 } from '../node_modules/gl-matrix/esm/index.js';

        let width = window.innerWidth;
        let height =  window.innerHeight;

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        document.body.appendChild(canvas);

        let gpu, context;

        async function main() {
            gpu = new GPU();
            await gpu.init();

            context = new Context(canvas);
            await context.init(gpu.device);

            const renderPipeline = gpu.createRenderPipeline(vsCode, fsCode, {
                // indexFormat: 'uint32',
                vertexBuffers: [{
                    arrayStride: 4 * 5,
                    attributes: [
                        // position
                        {
                            shaderLocation: 0,
                            offset: 0,
                            format: 'float3'
                        },
                        // uv
                        {
                            shaderLocation: 1,
                            offset: 4 * 3,
                            format: 'float2'
                        }
                    ]
                }]
            }, {
                entries: [{
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    type: 'uniform-buffer'
                }, {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    type: "sampler"
                }, {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    type: "sampled-texture"
                }]
            }, context.format);

            // texture

            const sampler = gpu.device.createSampler({
                magFilter: "linear",
                minFilter: "linear",
            });

            const imageInfo = await loadImage('./textures/crate.gif');
            const texture = gpu.createTexture(imageInfo.data, imageInfo.width, imageInfo.height);

            // camera

            const pMatrix = mat4.perspective(mat4.create(), Math.PI / 4, width / height, 0.1, 50);

            // triangle

            const triangleMVMatrix = mat4.fromTranslation(mat4.create(), new Float32Array([-1.5, 0.0, -7.0]));

            const triangleUniformBufferView = new Float32Array(16 * 2);
            triangleUniformBufferView.set(pMatrix);
            triangleUniformBufferView.set(triangleMVMatrix, 16);

            const triangleVertexBuffer = gpu.createBuffer(new Float32Array([
                0.0, 1.0, 0.0, 0.5, 0,
                -1.0, -1.0, 0.0, 0, 1,
                1.0, -1.0, 0.0, 1, 1
            ]), GPUBufferUsage.VERTEX);

            const triangleIndexBuffer = gpu.createBuffer(new Uint32Array([0, 1, 2]), GPUBufferUsage.INDEX);

            const triangleUniformBuffer = gpu.createBuffer(triangleUniformBufferView, GPUBufferUsage.UNIFORM);
            const triangleUniformGroup = renderPipeline.createUniformGroup([
                triangleUniformBuffer,
                sampler,
                texture
            ]);

            // square

            const squareMVMatrix = mat4.fromTranslation(mat4.create(), new Float32Array([1.5, 0.0, -7.0]));

            const squareUniformBufferView = new Float32Array(16 * 2);
            squareUniformBufferView.set(pMatrix);
            squareUniformBufferView.set(squareMVMatrix, 16);

            const squareVertexBuffer = gpu.createBuffer(new Float32Array([
                1.0, 1.0, 0.0, 1.0, 1.0,
                -1.0, 1.0, 0.0, 0.0, 1.0,
                1.0, -1.0, 0.0, 1.0, 0.0,
                -1.0, -1.0, 0.0, 0.0, 0.0
            ]), GPUBufferUsage.VERTEX);

            const squareIndexBuffer = gpu.createBuffer(new Uint32Array([0, 1, 2, 1, 2, 3]), GPUBufferUsage.INDEX);

            const squareUniformBuffer = gpu.createBuffer(squareUniformBufferView, GPUBufferUsage.UNIFORM);
            const squareUniformGroup = renderPipeline.createUniformGroup([
                squareUniformBuffer,
                sampler,
                texture
            ]);

            // resize handle

            window.addEventListener('resize', () => {
                width = window.innerWidth;
                height = window.innerHeight;

                canvas.width = width;
                canvas.height = height;

                mat4.perspective(pMatrix, Math.PI / 4, width / height, 0.1, 50);

                triangleUniformBuffer.array.set(pMatrix);
                squareUniformBuffer.array.set(pMatrix);

                triangleUniformBuffer.dirty();
                squareUniformBuffer.dirty();
            });

            // render

            function render() {
                requestAnimationFrame(render);

                gpu.createCommandEncoder();

                let uploadBuffers = [
                    triangleUniformBuffer.$update(),
                    squareUniformBuffer.$update(),
                    texture.$update()
                ];

                gpu.beginRenderPass(
                    {
                        colorAttachments: [{
                            attachment: context.swapChain.getCurrentTexture().createView(),
                            loadValue: { r: 0, g: 0, b: 0, a: 1.0 }
                        }]
                    },
                    width,
                    height
                );
                
                gpu.setPipeline(renderPipeline);

                gpu.bindAttributes({
                    vertexBuffers: [triangleVertexBuffer],
                    indexBuffer: triangleIndexBuffer
                });

                gpu.bindUniforms(triangleUniformGroup);

                gpu.draw(triangleIndexBuffer.array.length);

                gpu.bindAttributes({
                    vertexBuffers: [squareVertexBuffer],
                    indexBuffer: squareIndexBuffer
                });

                gpu.bindUniforms(squareUniformGroup);

                gpu.draw(squareIndexBuffer.array.length);

                gpu.present();

                uploadBuffers.forEach(uploadBuffer => {
                    if(uploadBuffer) uploadBuffer.destroy();
                });
            }

            requestAnimationFrame(render);
        }

        main();
    </script>
</body>
</html>